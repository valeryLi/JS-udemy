() передаем аргумент/ы. 
Название функции пишем глагол + приписка, камелкейс; Также может быть и анонимной.

Если объявлена переменная внутри ф-ции, то вне ф-ции она не доступна. Локальная переменная.
Если переменная объявлена вне ф-ции это - глобальная.

Если мы записываем локально переменную, которая записана глобально, то ошибки не будет. 

ЗАМЫКАНИЕ функции
Когда у нас внутри какой-то ф-ции есть обращение к какой-то переменной.

let num = 20;

function showFirstMessage(text) {
  console.log(text);

  let num = 10;
  console.log(num);
}

showFirstMessage("Hello World!");
console.log(num);

Когда эта ф-ция запускается, она идет шаг за шагом.
1) создает аргумент с значением "Hello World!"
2) выводит в консоль этот аргумент
3) создает внутри себя переменную 
4)дальше идет обращение к названию этой переменной и эта ф-ция сначала ищет эту переменную внутри себя. То есть она сканирует сначала код, потом натыкается на переменную num и использует свою локальную переменную.

///// Если удалить локадьную переменную, то поведение немножко поменяется
let num = 20;

function showFirstMessage(text) {
  console.log(text);
  console.log(num);
}

showFirstMessage("Hello World!");
console.log(num);

Когда дайдет очередь до команды   console.log(num), она начнет сканировать функцию и внутри себя не найдет переменную num. В таком случае эта ф-ция начнет искать на уровень выше и наткнувшись на глобальную переменную num, будет использовать ее и в том консоле она тоже будет выведена.

Итог: Когда ф-ция вызывается по факту она пытается найти какие-то переменные, какие-то значения и если не находит она постоянно идет на уровень выше, до самого высшего уровня, который ей вообще доступен.
замыкание ф-ции это - сама функция вместе со всеми внешними переменными, которые ей доступны.


Классификация ф-ций(картинка прилагается)
1)Function declaration
У нее есть очень важная особенность, она существует уже до того как код запуститься. Точно так же как и переменная var, т.е при запуски html  файла запускается скрипт. Первым делом браузер пробегается по скрипту и находит все переменные var(если они есть), и все function declaration/ Он их создает и объявляет и дальше весь код идет по порядку.
Приимущество:
console.log(calc(4, 3));
console.log(calc(5, 6));
console.log(calc(10, 3));

function calc(a, b) {
  return a + b;
}
Ф-ция работает до того как она была вызвана.

2)Function expression (функциональное выражение)
Создается только тогда, когда до нее доходит поток кода, можно вызвать только после объявления.

const logger = function () {
  console.log("Hello");
};
logger();

3)Стрелочные функции
Современный стандарт ES6. В 2015 году была добавлена стрелочная функция.
Такая ф-ция не имеет контекста вызова(this).

const calc = (a, b) => a + b;

<!-- ///////////////////////////////////////////////////////////// -->
Don't repeat yourself(DRY)
Когда создается много повторяющихся и неуниверсальных функций. Поэтому важно понимать использование аргументов в функция для создания универсальных ф-ций.

const usdCurr = 28;

function convert(amount, curr) {
  console.log(curr * amount);
}

convert(500, usdCurr);

 return всегда что-то возвращает, даже если мы его не пропишем под капотом будет return undefined
function doNothing() {}
console.log(doNothing() === undefined); 
будет true

Вопрос из собеса:
Почему если в браузерной консоле передав что-то будет undefined?
console.log("11")
11
undefined
Консоль это большой объект. Лог это его метод, который выводит в консоль какое-то значение и так как это функция, она должна что-то возвращать. И эта ф-ция будет возвращать undefined, который и будет виден в консоле. Абсолютно любая ф-ция, которая не содержит ретерн будет возвращать undefined.